<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Monsters | You-Meet-In-A-Tavern (YMIAT)</title>
  <meta name="description" content="Monster stat blocks for You-Meet-In-A-Tavern (YMIAT)." />
  <link rel="canonical" href="rules/monsters.html" />
  <link rel="stylesheet" href="../assets/styles.css" />
  <script src="../assets/includes.js"></script>
  <meta property="og:title" content="Monsters | You-Meet-In-A-Tavern (YMIAT)" />
  <meta property="og:description" content="Monster stat blocks for You-Meet-In-A-Tavern (YMIAT)." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="rules/monsters.html" />
  <style>
    /* CR Filter Dual Range Slider Styles */
    .cr-filter-slider-container {
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .cr-slider-wrapper {
      position: relative;
      width: 100%;
      height: 28px;
    }

    .cr-slider-track {
      position: absolute;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
      top: 50%;
      transform: translateY(-50%);
      left: 11px;
      right: 11px;
    }

    .cr-slider {
      position: absolute;
      width: 100%;
      height: 8px;
      background: transparent;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      pointer-events: none;
      top: 50%;
      transform: translateY(-50%);
      margin: 0;
      padding: 0;
    }

    .cr-slider::-webkit-slider-runnable-track {
      width: 100%;
      height: 8px;
      background: transparent;
    }

    .cr-slider::-moz-range-track {
      width: 100%;
      height: 8px;
      background: transparent;
      border: none;
    }

    .cr-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--brand-secondary);
      cursor: pointer;
      pointer-events: all;
      border: 2px solid #fff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      margin-top: -7px;
    }

    .cr-slider::-moz-range-thumb {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--brand-secondary);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      pointer-events: all;
    }

    .cr-slider-min {
      z-index: 1;
    }

    .cr-slider-max {
      z-index: 2;
    }

    .cr-slider-ticks {
      display: flex;
      justify-content: space-between;
      padding: 4px 0 0 0;
    }

    .cr-slider-ticks span {
      font-size: 0.7rem;
      color: var(--text-secondary, #888);
      width: 0;
      text-align: center;
    }

    .cr-slider-labels {
      display: none;
    }

    /* Monster cards grid - 2 per row like spell cards */
    #monsters-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }

    .monster-item {
      border: 2px solid var(--fantasy-gold);
      border-radius: var(--r2);
      background: linear-gradient(135deg, rgba(255,255,255,.98), rgba(250,248,244,.95));
      box-shadow: var(--shadow);
      break-inside: avoid;
      position: relative;
    }

    .monster-card-checkbox {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: var(--fantasy-gold);
      z-index: 5;
    }

    .monster-item:has(.monster-card-checkbox:checked) {
      border-color: var(--fantasy-gold-light);
      box-shadow: 0 4px 12px rgba(184,134,11,.3);
    }

    .monster-item .lineage-header {
      background: transparent;
      padding: 14px 40px 14px 16px;
    }

    .monster-item .lineage-header:hover {
      background: rgba(184,134,11,.05);
    }

    .monster-item .lineage-title {
      color: var(--fantasy-blue);
      font-weight: 700;
    }

    .monster-item .lineage-subtitle {
      color: var(--fantasy-burgundy);
      font-weight: 600;
    }

    .monster-item .lineage-content {
      border-top: 1px solid rgba(184,134,11,.2);
      padding: 0 16px 16px;
    }

    @media (prefers-color-scheme: dark) {
      .monster-item {
        background: var(--bg-card);
        border-color: var(--accent-gold-soft);
      }

      .monster-item .lineage-header:hover {
        background: rgba(255,255,255,.03);
      }

      .monster-item .lineage-title {
        color: var(--text-primary);
      }
    }

    @media (max-width: 768px) {
      #monsters-container {
        grid-template-columns: 1fr;
      }
    }

    .monster-stat-block-content {
      margin-top: 10px;
    }

    .stat-block-top-row {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }

    .stat-block-top-row .stat-block-stats {
      flex: 1 1 50%;
    }

    .stat-block-top-row .stat-block-stats .basic-stats {
      margin: 0;
      line-height: 1.6;
      font-size: 0.9rem;
    }

    .stat-block-top-row .ability-scores-table {
      flex: 1 1 50%;
      min-width: 0;
    }

    .ability-scores-vertical {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    .ability-scores-vertical th {
      text-align: left;
      font-weight: 700;
      padding: 2px 8px 2px 0;
      white-space: nowrap;
      color: var(--brand-primary);
    }

    .ability-scores-vertical td {
      text-align: center;
      padding: 2px 12px 2px 0;
      font-variant-numeric: tabular-nums;
    }

    .stat-block-details {
      font-size: 0.9rem;
      line-height: 1.6;
      padding: 4px 0;
      border-top: 1px solid rgba(184,134,11,.2);
      margin-top: 4px;
    }

    .monster-etf-version {
      display: block;
    }

    .monster-original-version {
      display: none;
    }

    .monster-controls-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 20px;
      margin: 15px 0;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 5px;
    }

    .monster-level-scaling {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .monster-level-scaling label {
      font-weight: bold;
      margin: 0;
    }

    .monster-level-scaling select {
      padding: 5px 10px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 14px;
    }

    /* Individual monster toggle switch */
    .monster-toggle-switch {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      user-select: none;
    }

    .monster-toggle-switch input {
      display: none;
    }

    .monster-toggle-slider {
      position: relative;
      width: 44px;
      height: 24px;
      background: #ccc;
      border-radius: 24px;
      transition: background 0.3s;
    }

    .monster-toggle-slider::before {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      left: 3px;
      top: 3px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .monster-toggle-switch input:checked+.monster-toggle-slider {
      background: var(--brand-secondary);
    }

    .monster-toggle-switch input:checked+.monster-toggle-slider::before {
      transform: translateX(20px);
    }

    .monster-toggle-label {
      font-size: 0.9rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .lineage-subtitle {
      font-size: 0.9em;
      color: var(--text-secondary);
      font-weight: normal;
      margin-left: 10px;
    }

    @media (prefers-color-scheme: dark) {
      .monster-controls-row {
        background: rgba(255, 255, 255, 0.05);
      }
    }

    /* Filter drawer button */
    .filter-drawer-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 6px;
      background: var(--brand-secondary);
      color: white;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
      margin-top: 5px;
    }

    .filter-drawer-btn:hover {
      background: color-mix(in srgb, var(--brand-secondary) 85%, black);
    }

    .filter-drawer-btn .toggle-filters-icon {
      font-size: 0.8em;
      transition: transform 0.2s ease;
    }

    /* Multi-select dropdown with chips */
    .filter-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px 20px;
      margin: 10px 0;
    }

    .multi-select-filter {
      margin: 0;
    }

    .multi-select-filter label {
      display: block;
      font-weight: bold;
      margin-bottom: 8px;
      color: var(--text-primary);
      font-size: 0.9rem;
    }

    .multi-select-dropdown {
      position: relative;
      width: 100%;
      z-index: 100;
    }

    .multi-select-input {
      display: flex;
      gap: 6px;
      min-height: 40px;
      padding: 6px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      align-items: center;
      position: relative;
    }

    .chips-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      flex: 1;
      align-items: center;
    }

    .multi-select-controls {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-left: auto;
      padding-left: 6px;
    }

    .clear-all-btn {
      background: none;
      border: none;
      color: #999;
      font-size: 1.1rem;
      cursor: pointer;
      padding: 2px 4px;
      line-height: 1;
      transition: color 0.2s;
    }

    .clear-all-btn:hover {
      color: #333;
    }

    .dropdown-arrow {
      color: #999;
      font-size: 0.8rem;
      pointer-events: none;
      line-height: 1;
    }

    .multi-select-input:hover {
      border-color: var(--brand-secondary);
    }

    .multi-select-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      background: var(--brand-secondary);
      color: white;
      border-radius: 16px;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    .multi-select-chip-remove {
      cursor: pointer;
      font-weight: bold;
      padding: 0 4px;
      border-radius: 50%;
      transition: background 0.2s;
    }

    .multi-select-chip-remove:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .multi-select-placeholder {
      color: #999;
      font-size: 0.95rem;
      padding: 4px;
    }

    .multi-select-options {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 250px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ddd;
      border-top: none;
      border-radius: 0 0 4px 4px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 10000;
      display: none;
    }

    .multi-select-options.open {
      display: block;
    }

    .multi-select-option {
      padding: 10px 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .multi-select-option:hover {
      background: rgba(106, 90, 205, 0.1);
    }

    .multi-select-option.selected {
      background: rgba(106, 90, 205, 0.2);
      font-weight: 500;
    }

    .toggle-filters {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      margin: 15px 0;
    }

    .filter-toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      color: var(--text-primary);
    }

    .filter-toggle input[type="checkbox"] {
      display: none;
    }

    .filter-toggle-slider {
      position: relative;
      width: 44px;
      height: 24px;
      background: #ccc;
      border-radius: 12px;
      transition: background 0.3s;
      flex-shrink: 0;
    }

    .filter-toggle-slider::before {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .filter-toggle input[type="checkbox"]:checked + .filter-toggle-slider {
      background: var(--brand-secondary);
    }

    .filter-toggle input[type="checkbox"]:checked + .filter-toggle-slider::before {
      transform: translateX(20px);
    }

    .filter-toggle-label {
      font-size: 0.95rem;
    }

    @media (prefers-color-scheme: dark) {
      .multi-select-input {
        background: #2a2a2a;
        border-color: #555;
        color: #fff;
      }

      .multi-select-options {
        background: #2a2a2a;
        border-color: #555;
      }

      .multi-select-option:hover {
        background: rgba(106, 90, 205, 0.2);
      }

      .multi-select-option.selected {
        background: rgba(106, 90, 205, 0.3);
      }

      .clear-all-btn {
        color: #aaa;
      }

      .clear-all-btn:hover {
        color: #fff;
      }

      .dropdown-arrow {
        color: #aaa;
      }

      .filter-toggle-slider {
        background: #555;
      }
    }

    /* Print styles */
    @media print {
      header, nav, .print-controls, .lineages-controls, footer, h1, h2,
      .content > p, .content > .lede, .filter-drawer-btn {
        display: none !important;
      }

      body {
        background: #fff !important;
        margin: 0;
        padding: 0;
      }

      .content {
        max-width: 100% !important;
        padding: 0 !important;
        margin: 0 !important;
      }

      /* Hide unselected monsters */
      .monster-item:not(.print-selected) {
        display: none !important;
      }

      /* Grid layout for printing */
      #monsters-container {
        display: grid !important;
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 10px !important;
        margin: 0 !important;
      }

      /* Card styling for print */
      .monster-item {
        border: 2px solid #000 !important;
        border-radius: 6px !important;
        padding: 0 !important;
        page-break-inside: avoid !important;
        break-inside: avoid !important;
        background: #fff !important;
        box-shadow: none !important;
      }

      .monster-card-checkbox {
        display: none !important;
      }

      .monster-item .lineage-header {
        padding: 8px 12px !important;
      }

      .lineage-title {
        color: #000 !important;
        font-size: 1rem !important;
      }

      .lineage-subtitle {
        color: #333 !important;
      }

      .lineage-toggle-icon {
        display: none !important;
      }

      /* Force content visible for selected cards */
      .print-selected .lineage-content {
        display: block !important;
        border-top: 1px solid #000 !important;
        padding: 4px 12px 8px !important;
      }

      /* Hide interactive controls in print */
      .monster-controls-row {
        display: none !important;
      }

      .monster-stat-block-content {
        margin-top: 0 !important;
      }

      /* Stat block text */
      .monster-etf-version,
      .monster-original-version {
        color: #000 !important;
        font-size: 0.85rem !important;
      }

      @page {
        margin: 1.5cm;
        size: A4;
      }
    }
  </style>
</head>

<body>
  <header data-include="nav"></header>
  <main>
    <h1>Monsters</h1>
    <div class="content">
      <p class="lede">This page contains monster stat blocks from the Black Flag Reference Document, converted to the
        <strong>You-Meet-In-A-Tavern</strong> (YMIAT) system. All monsters are displayed with their
        <strong>You-Meet-In-A-Tavern</strong> (YMIAT)-converted stats by default, with the option to view original D&D
        5e stat blocks.</p>

      <p>Monsters can be scaled to different levels using the level dropdown. This adjusts Defense Save DCs, damage, and
        other scalable properties based on the monster's Challenge Rating (CR).</p>

      <h2>Browse Monsters</h2>
      <p>Looking for the original Black Flag Reference Document monsters organized by CR?</p>
      <p><a href="monsters-bfrd.html" class="btn">Browse BFRD Monsters by CR →</a></p>

      <div class="print-controls">
        <div class="search-row">
          <label for="monster-search" class="search-label">Search monsters:</label>
          <input type="text" id="monster-search" class="spell-search-input" placeholder="Type monster name to search..."
            oninput="handleMonsterSearch()" />
        </div>
        <div class="control-row">
          <button onclick="selectAllMonsters()">Select All</button>
          <button onclick="deselectAllMonsters()">Deselect All</button>
          <button onclick="printSelectedMonsters()">Print Selected</button>
          <span id="monster-selected-count">0 monsters selected</span>
        </div>
        <div id="filters-container" class="filters-container">
          <div class="filter-grid">
            <div class="multi-select-filter">
              <label>Level</label>
              <div class="cr-filter-slider-container">
                <div class="cr-slider-wrapper">
                  <div class="cr-slider-track"></div>
                  <input type="range" id="cr-min-slider" class="cr-slider cr-slider-min" min="1" max="10" value="1"
                    step="1" oninput="updateCRFilter()" />
                  <input type="range" id="cr-max-slider" class="cr-slider cr-slider-max" min="1" max="10" value="10"
                    step="1" oninput="updateCRFilter()" />
                </div>
                <div class="cr-slider-ticks">
                  <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span>
                  <span>6</span><span>7</span><span>8</span><span>9</span><span>10</span>
                </div>
                <div class="cr-slider-labels">
                  <span class="cr-slider-label-min">Min: <span id="cr-min-value">1</span></span>
                  <span class="cr-slider-label-max">Max: <span id="cr-max-value">10</span></span>
                </div>
              </div>
            </div>

            <div class="multi-select-filter">
              <label>Type</label>
              <div class="multi-select-dropdown" id="type-filter-dropdown">
                <div class="multi-select-input" onclick="toggleMultiSelect('type-filter')">
                  <div id="type-filter-chips" class="chips-container"></div>
                  <span class="multi-select-placeholder" id="type-filter-placeholder">Select types...</span>
                  <div class="multi-select-controls">
                    <button class="clear-all-btn" id="type-filter-clear"
                      onclick="event.stopPropagation(); clearAll('type-filter')" style="display: none;"
                      title="Clear all">✕</button>
                    <span class="dropdown-arrow">▼</span>
                  </div>
                </div>
                <div class="multi-select-options" id="type-filter-options"></div>
              </div>
            </div>

            <div class="multi-select-filter">
              <label>Size</label>
              <div class="multi-select-dropdown" id="size-filter-dropdown">
                <div class="multi-select-input" onclick="toggleMultiSelect('size-filter')">
                  <div id="size-filter-chips" class="chips-container"></div>
                  <span class="multi-select-placeholder" id="size-filter-placeholder">Select sizes...</span>
                  <div class="multi-select-controls">
                    <button class="clear-all-btn" id="size-filter-clear"
                      onclick="event.stopPropagation(); clearAll('size-filter')" style="display: none;"
                      title="Clear all">✕</button>
                    <span class="dropdown-arrow">▼</span>
                  </div>
                </div>
                <div class="multi-select-options" id="size-filter-options"></div>
              </div>
            </div>

            <div class="multi-select-filter">
              <label>Immunities</label>
              <div class="multi-select-dropdown" id="immunities-filter-dropdown">
                <div class="multi-select-input" onclick="toggleMultiSelect('immunities-filter')">
                  <div id="immunities-filter-chips" class="chips-container"></div>
                  <span class="multi-select-placeholder" id="immunities-filter-placeholder">Select immunities...</span>
                  <div class="multi-select-controls">
                    <button class="clear-all-btn" id="immunities-filter-clear"
                      onclick="event.stopPropagation(); clearAll('immunities-filter')" style="display: none;"
                      title="Clear all">✕</button>
                    <span class="dropdown-arrow">▼</span>
                  </div>
                </div>
                <div class="multi-select-options" id="immunities-filter-options"></div>
              </div>
            </div>

            <div class="multi-select-filter">
              <label>Languages</label>
              <div class="multi-select-dropdown" id="languages-filter-dropdown">
                <div class="multi-select-input" onclick="toggleMultiSelect('languages-filter')">
                  <div id="languages-filter-chips" class="chips-container"></div>
                  <span class="multi-select-placeholder" id="languages-filter-placeholder">Select languages...</span>
                  <div class="multi-select-controls">
                    <button class="clear-all-btn" id="languages-filter-clear"
                      onclick="event.stopPropagation(); clearAll('languages-filter')" style="display: none;"
                      title="Clear all">✕</button>
                    <span class="dropdown-arrow">▼</span>
                  </div>
                </div>
                <div class="multi-select-options" id="languages-filter-options"></div>
              </div>
            </div>

            <div class="multi-select-filter">
              <label>Senses</label>
              <div class="multi-select-dropdown" id="senses-filter-dropdown">
                <div class="multi-select-input" onclick="toggleMultiSelect('senses-filter')">
                  <div id="senses-filter-chips" class="chips-container"></div>
                  <span class="multi-select-placeholder" id="senses-filter-placeholder">Select senses...</span>
                  <div class="multi-select-controls">
                    <button class="clear-all-btn" id="senses-filter-clear"
                      onclick="event.stopPropagation(); clearAll('senses-filter')" style="display: none;"
                      title="Clear all">✕</button>
                    <span class="dropdown-arrow">▼</span>
                  </div>
                </div>
                <div class="multi-select-options" id="senses-filter-options"></div>
              </div>
            </div>

            <div class="toggle-filters">
              <label class="filter-toggle">
                <input type="checkbox" id="resistances-toggle" onchange="applyFilters()">
                <span class="filter-toggle-slider"></span>
                <span class="filter-toggle-label">Has Magic Resistance</span>
              </label>
              <label class="filter-toggle">
                <input type="checkbox" id="legendary-toggle" onchange="applyFilters()">
                <span class="filter-toggle-slider"></span>
                <span class="filter-toggle-label">Has Legendary Actions</span>
              </label>
            </div>
          </div>
        </div>
        <button id="toggle-filters-btn" class="filter-drawer-btn" onclick="toggleFilters()">
          <span class="toggle-filters-icon">▽</span>
          <span class="toggle-filters-text">Filters</span>
          <span class="toggle-filters-icon">▽</span>
        </button>
      </div>

      <div class="lineages-controls">
        <button id="expand-all-monsters" class="lineage-control-btn" onclick="expandAllMonsters()">Expand All</button>
        <button id="collapse-all-monsters" class="lineage-control-btn" onclick="collapseAllMonsters()">Collapse
          All</button>
      </div>

      <div class="lineages-container" id="monsters-container">
        <!-- Monsters will be loaded here via JavaScript -->
      </div>

      <!-- Monster stat block template -->
      <template id="monster-stat-block-template">
        <div class="stat-block-header">
          <p class="stat-block-title"><span class="cr-level-label"></span><br /><em class="size-type"></em></p>
        </div>
        <div class="stat-block-top-row">
          <div class="stat-block-stats">
            <p class="basic-stats">
              <strong>AC</strong> <span class="ac"></span><br />
              <strong>HP</strong> <span class="hp"></span><br />
              <strong>Speed</strong> <span class="speed"></span><br />
              <strong>Perception</strong> <span class="perception"></span> <strong>Stealth</strong> <span
                class="stealth"></span>
            </p>
          </div>
          <div class="ability-scores-table"></div>
        </div>
        <div class="stat-block-details">
          <span class="resistances-block"></span>
          <span class="immunities-block"></span>
          <strong>Senses</strong> <span class="senses"></span><br />
          <strong>Languages</strong> <span class="languages"></span>
        </div>
        <hr />
        <div class="traits-section"></div>
        <div class="actions-section"></div>
        <div class="bonus-actions-section"></div>
        <div class="reactions-section"></div>
        <div class="legendary-actions-section"></div>
      </template>
    </div>
  </main>
  <footer class="legal" data-include="footer"></footer>
  <script src="../assets/monster-renderer.js"></script>
  <script>
    // CR to Level mapping (same as monster-abilities.html)
    function crToLevel(cr) {
      if (cr <= 0) return 1;
      if (cr <= 1) return 1;
      if (cr <= 3) return 2;
      if (cr <= 5) return 3;
      if (cr <= 7) return 4;
      if (cr <= 9) return 5;
      if (cr <= 11) return 6;
      if (cr <= 13) return 7;
      if (cr <= 15) return 8;
      if (cr <= 17) return 9;
      return 10;
    }

    // Scale numeric values in description text (saves, DCs)
    function scaleDescriptionText(text, levelDiff) {
      // Scale "X to save" (weapon attacks)
      text = text.replace(/(\d+) to save/g, (_, n) =>
        `${Math.max(1, parseInt(n) + levelDiff)} to save`);
      // Scale "DC X" (ability saves, escape DCs, spell attack DCs)
      text = text.replace(/\bDC (\d+)/g, (_, n) =>
        `DC ${Math.max(1, parseInt(n) + levelDiff)}`);
      return text;
    }

    // Deep-clone monster data and scale all ymiat values
    function scaleMonsterData(monster, levelDiff) {
      if (levelDiff === 0) return monster;
      const m = JSON.parse(JSON.stringify(monster));
      const y = m.ymiat;

      y.hp = Math.max(1, y.hp + levelDiff);
      y.ac = Math.max(1, y.ac + Math.trunc(levelDiff / 2));
      y.perception = Math.max(1, y.perception + levelDiff);
      y.stealth = Math.max(1, y.stealth + levelDiff);

      for (const key of Object.keys(y.abilities)) {
        y.abilities[key] += levelDiff;
      }

      for (const section of ['traits', 'actions', 'bonus_actions', 'reactions', 'legendary_actions']) {
        for (const item of y[section]) {
          item.description = scaleDescriptionText(item.description, levelDiff);
        }
      }

      m.level = Math.max(1, (m.level || crToLevel(monster.cr)) + levelDiff);
      return m;
    }

    // Format CR value for display
    function formatCR(cr) {
      if (cr === 0) return '0';
      if (cr === 0.125) return '1/8';
      if (cr === 0.25) return '1/4';
      if (cr === 0.5) return '1/2';
      return cr.toString();
    }

    // Parse CR value from string
    function parseCR(crStr) {
      if (crStr === '0') return 0;
      if (crStr === '1/8') return 0.125;
      if (crStr === '1/4') return 0.25;
      if (crStr === '1/2') return 0.5;
      return parseFloat(crStr) || 0;
    }

    // Load monsters data
    let monstersData = [];

    async function loadMonstersData() {
      if (monstersData.length > 0) return monstersData;

      try {
        const response = await fetch('../data/monsters_data.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        monstersData = await response.json();
        return monstersData;
      } catch (error) {
        console.error('Failed to load monsters data:', error);
        return [];
      }
    }

    // Render monsters with optimized batch rendering
    async function renderMonsters() {
      const data = await loadMonstersData();
      const container = document.getElementById('monsters-container');

      if (!container) return;

      // Show loading indicator
      container.innerHTML = '<p>Loading monsters...</p>';

      // Sort monsters by CR, then by name
      const sorted = [...data].sort((a, b) => {
        if (a.cr !== b.cr) return a.cr - b.cr;
        return a.name.localeCompare(b.name);
      });

      // Build HTML string in memory first (much faster than innerHTML +=)
      const htmlParts = [];

      sorted.forEach((monster, index) => {
        const monsterId = `monster-${index}`;
        const safeId = monsterId.replace(/[^a-z0-9-]/gi, '-');
        const defaultLevel = crToLevel(monster.cr);

        const monsterLevel = monster.level || crToLevel(monster.cr);
        htmlParts.push(`
      <div class="lineage-item monster-item" data-monster-name="${escapeHtml(monster.name.toLowerCase())}" data-cr="${monster.cr}" data-level="${monsterLevel}" data-type="${escapeHtml(monster.type || '')}" data-size="${escapeHtml(monster.size || '')}" data-immunities="${escapeHtml(monster.ymiat?.immunities || '')}" data-resistances="${monster.ymiat?.resistances ? 'true' : 'false'}" data-languages="${escapeHtml(monster.ymiat?.languages || '')}" data-senses="${escapeHtml(monster.ymiat?.senses || '')}" data-has-legendary="${(monster.ymiat?.legendary_actions?.length > 0) ? 'true' : 'false'}" id="item-${safeId}">
        <input type="checkbox" class="monster-card-checkbox" onchange="updateMonsterCount()">
        <button class="lineage-header" onclick="toggleMonster(this)">
          <span class="lineage-title">${escapeHtml(monster.name)}</span>
          <span class="lineage-subtitle" id="${safeId}-cr-label">Level ${monsterLevel}</span>
          <span class="lineage-toggle-icon">▼</span>
        </button>
        <div class="lineage-content">
          <div class="monster-controls-row">
            <div class="monster-level-scaling">
              <label for="${safeId}-level">Scale for level:</label>
              <select id="${safeId}-level" class="level-scaling-select" onchange="updateMonsterScaling('${safeId}', ${monster.cr})">
                ${[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(lvl =>
          `<option value="${lvl}" ${lvl === defaultLevel ? 'selected' : ''}>Level ${lvl}</option>`
        ).join('')}
              </select>
            </div>
            <label class="monster-toggle-switch">
              <input type="checkbox" id="${safeId}-toggle" onchange="toggleMonsterStats('${safeId}')">
              <span class="monster-toggle-slider"></span>
              <span class="monster-toggle-label">5e stats</span>
            </label>
          </div>
          <div class="monster-stat-block-content">
            <div class="monster-etf-version" id="${safeId}-etf" data-monster-index="${index}"></div>
            <div class="monster-original-version" id="${safeId}-original" data-monster-index="${index}" style="display:none;"></div>
          </div>
        </div>
      </div>
    `);
      });

      // Set innerHTML once with all content (much faster)
      container.innerHTML = htmlParts.join('');

      // Render stat blocks using template (use requestAnimationFrame for better performance)
      requestAnimationFrame(() => {
        document.querySelectorAll('.monster-item').forEach(item => {
          const etfDiv = item.querySelector('.monster-etf-version');
          const originalDiv = item.querySelector('.monster-original-version');

          const monsterIndex = parseInt(etfDiv.getAttribute('data-monster-index'));
          const monster = sorted[monsterIndex];

          // Render YMIAT version
          const ymiatBlock = renderStatBlock(monster, true);
          etfDiv.innerHTML = ymiatBlock.innerHTML;

          // Render 5e version
          const originalBlock = renderStatBlock(monster, false);
          originalDiv.innerHTML = originalBlock.innerHTML;
        });

        // Initialize all collapsed
        document.querySelectorAll('.lineage-content').forEach(content => {
          content.style.display = 'none';
        });

        // Apply filters after rendering
        applyFilters();
      });
    }

    // Toggle monster accordion
    function toggleMonster(button) {
      const item = button.closest('.lineage-item');
      const content = item.querySelector('.lineage-content');
      const icon = button.querySelector('.lineage-toggle-icon');
      const isExpanded = content.style.display === 'block' || content.classList.contains('expanded');

      if (isExpanded) {
        content.style.display = 'none';
        content.classList.remove('expanded');
        icon.textContent = '▼';
        button.setAttribute('aria-expanded', 'false');
      } else {
        content.style.display = 'block';
        content.classList.add('expanded');
        icon.textContent = '▲';
        button.setAttribute('aria-expanded', 'true');
      }
    }

    // Toggle between YMIAT and 5e stats for individual monster
    function toggleMonsterStats(monsterId) {
      const toggle = document.getElementById(`${monsterId}-toggle`);
      const etfVersion = document.getElementById(`${monsterId}-etf`);
      const originalVersion = document.getElementById(`${monsterId}-original`);
      const crLabel = document.getElementById(`${monsterId}-cr-label`);

      // Get the monster item to access its data
      const item = document.getElementById(`item-${monsterId}`);
      if (!item) return;

      const cr = parseFloat(item.getAttribute('data-cr')) || 0;
      const level = parseInt(item.getAttribute('data-level')) || crToLevel(cr);

      if (toggle.checked) {
        // Show original 5e stats
        etfVersion.style.display = 'none';
        originalVersion.style.display = 'block';
        if (crLabel) crLabel.textContent = `CR ${formatCR(cr)}`;
      } else {
        // Show YMIAT stats
        etfVersion.style.display = 'block';
        originalVersion.style.display = 'none';
        if (crLabel) crLabel.textContent = `Level ${level}`;
      }
    }

    // Expand/Collapse all
    function expandAllMonsters() {
      document.querySelectorAll('.lineage-content').forEach(content => {
        content.style.display = 'block';
        content.classList.add('expanded');
      });
      document.querySelectorAll('.lineage-toggle-icon').forEach(icon => {
        icon.textContent = '▲';
      });
      document.querySelectorAll('.lineage-header').forEach(button => {
        button.setAttribute('aria-expanded', 'true');
      });
    }

    function collapseAllMonsters() {
      document.querySelectorAll('.lineage-content').forEach(content => {
        content.style.display = 'none';
        content.classList.remove('expanded');
      });
      document.querySelectorAll('.lineage-toggle-icon').forEach(icon => {
        icon.textContent = '▼';
      });
      document.querySelectorAll('.lineage-header').forEach(button => {
        button.setAttribute('aria-expanded', 'false');
      });
    }

    // Toggle between You-Meet-In-A-Tavern (YMIAT) and Original stats
    function toggleOriginalStats() {
      const showOriginal = document.getElementById('toggle-original-stats').checked;

      // Update filter slider based on toggle state
      const minSlider = document.getElementById('cr-min-slider');
      const maxSlider = document.getElementById('cr-max-slider');
      const minValue = document.getElementById('cr-min-value');
      const maxValue = document.getElementById('cr-max-value');
      const filterLabel = document.getElementById('filter-label');

      if (showOriginal) {
        // Show CR filter (0-30)
        filterLabel.textContent = 'Filter by CR (Challenge Rating):';
        minSlider.min = 0;
        minSlider.max = 30;
        minSlider.value = 0;
        maxSlider.min = 0;
        maxSlider.max = 30;
        maxSlider.value = 30;
        minValue.textContent = '0';
        maxValue.textContent = '30';
      } else {
        // Show Level filter (1-10)
        filterLabel.textContent = 'Filter by Level:';
        minSlider.min = 1;
        minSlider.max = 10;
        minSlider.value = 1;
        maxSlider.min = 1;
        maxSlider.max = 10;
        maxSlider.value = 10;
        minValue.textContent = '1';
        maxValue.textContent = '10';
      }

      // Update slider track tick marks
      updateSliderTicks();

      document.querySelectorAll('.monster-item').forEach(item => {
        const etfDiv = item.querySelector('.monster-etf-version');
        const originalDiv = item.querySelector('.monster-original-version');

        if (showOriginal) {
          if (etfDiv) etfDiv.style.display = 'none';
          if (originalDiv) originalDiv.style.display = 'block';
        } else {
          if (etfDiv) etfDiv.style.display = 'block';
          if (originalDiv) originalDiv.style.display = 'none';
        }
      });

      // Reapply filters with new criteria
      applyFilters();
    }

    // Update slider track tick marks based on current range
    function updateSliderTicks() {
      const minSlider = document.getElementById('cr-min-slider');
      const maxSlider = document.getElementById('cr-max-slider');
      const track = document.querySelector('.cr-slider-track');

      if (!minSlider || !maxSlider || !track) return;

      const min = parseInt(minSlider.min);
      const max = parseInt(maxSlider.max);
      const range = max - min + 1;

      // Update CSS for tick marks
      track.style.backgroundImage = `repeating-linear-gradient(
    to right,
    transparent 0,
    transparent calc(100% / ${range} - 1px),
    #999 calc(100% / ${range} - 1px),
    #999 calc(100% / ${range})
  )`;
    }

    // Update CR/Level filter slider values
    function updateCRFilter() {
      const minSlider = document.getElementById('cr-min-slider');
      const maxSlider = document.getElementById('cr-max-slider');
      const minValue = document.getElementById('cr-min-value');
      const maxValue = document.getElementById('cr-max-value');

      let min = parseInt(minSlider.value);
      let max = parseInt(maxSlider.value);

      // Ensure min <= max (they can be equal)
      if (min > max) {
        // If min slider moved past max, set min to max
        if (minSlider === document.activeElement) {
          min = max;
          minSlider.value = min;
        }
        // If max slider moved below min, set max to min
        else if (maxSlider === document.activeElement) {
          max = min;
          maxSlider.value = max;
        }
      }

      minValue.textContent = min;
      maxValue.textContent = max;

      // Apply filter
      applyFilters();
    }

    // Search functionality
    function handleMonsterSearch() {
      applyFilters();
    }

    // Print selection functions
    function updateMonsterCount() {
      const checked = document.querySelectorAll('.monster-card-checkbox:checked').length;
      const el = document.getElementById('monster-selected-count');
      if (el) el.textContent = checked + ' monster' + (checked !== 1 ? 's' : '') + ' selected';
    }

    function selectAllMonsters() {
      document.querySelectorAll('.monster-card-checkbox').forEach(cb => {
        if (cb.closest('.monster-item').style.display !== 'none') cb.checked = true;
      });
      updateMonsterCount();
    }

    function deselectAllMonsters() {
      document.querySelectorAll('.monster-card-checkbox').forEach(cb => cb.checked = false);
      updateMonsterCount();
    }

    function printSelectedMonsters() {
      const checked = document.querySelectorAll('.monster-card-checkbox:checked').length;
      if (checked === 0) {
        alert('Please select at least one monster to print.');
        return;
      }

      // Expand all selected monsters so their stat blocks are visible
      document.querySelectorAll('.monster-item').forEach(card => {
        const checkbox = card.querySelector('.monster-card-checkbox');
        if (checkbox && checkbox.checked) {
          card.classList.add('print-selected');
          const content = card.querySelector('.lineage-content');
          if (content) content.classList.add('expanded');
        } else {
          card.classList.remove('print-selected');
        }
      });

      window.print();
    }

    // Apply all filters
    function applyFilters() {
      const searchTerm = (document.getElementById('monster-search')?.value || '').toLowerCase();
      const minSlider = document.getElementById('cr-min-slider');
      const maxSlider = document.getElementById('cr-max-slider');
      const showOriginal = false; // No global toggle - each monster has individual toggle
      const requireResistances = document.getElementById('resistances-toggle')?.checked || false;
      const requireLegendary = document.getElementById('legendary-toggle')?.checked || false;

      if (!minSlider || !maxSlider) return;

      const minValue = parseInt(minSlider.value);
      const maxValue = parseInt(maxSlider.value);

      let visibleCount = 0;

      document.querySelectorAll('.monster-item').forEach(item => {
        const name = (item.getAttribute('data-monster-name') || '').toLowerCase();
        const type = item.getAttribute('data-type') || '';
        const size = item.getAttribute('data-size') || '';
        const immunities = item.getAttribute('data-immunities') || '';
        const languages = item.getAttribute('data-languages') || '';
        const senses = item.getAttribute('data-senses') || '';
        const hasResistances = item.getAttribute('data-resistances') === 'true';
        const hasLegendary = item.getAttribute('data-has-legendary') === 'true';

        // Check search
        const matchesSearch = !searchTerm || name.includes(searchTerm);

        // Check level/CR
        let matchesLevel = false;
        if (showOriginal) {
          const cr = parseFloat(item.getAttribute('data-cr')) || 0;
          const crInt = Math.round(cr);
          matchesLevel = crInt >= minValue && crInt <= maxValue;
        } else {
          const level = parseInt(item.getAttribute('data-level')) || 1;
          matchesLevel = level >= minValue && level <= maxValue;
        }

        // Check type filter
        const matchesType = filterSets['type-filter'].size === 0 || filterSets['type-filter'].has(type);

        // Check size filter
        const matchesSize = filterSets['size-filter'].size === 0 || filterSets['size-filter'].has(size);

        // Check immunities filter
        let matchesImmunities = true;
        if (filterSets['immunities-filter'].size > 0) {
          const monsterImmunities = parseImmunities(immunities);
          matchesImmunities = [...filterSets['immunities-filter']].some(selected => monsterImmunities.includes(selected));
        }

        // Check languages filter
        let matchesLanguages = true;
        if (filterSets['languages-filter'].size > 0) {
          const monsterLanguages = parseLanguages(languages);
          matchesLanguages = [...filterSets['languages-filter']].some(selected => monsterLanguages.includes(selected));
        }

        // Check senses filter
        let matchesSenses = true;
        if (filterSets['senses-filter'].size > 0) {
          const monsterSenses = parseSenses(senses);
          matchesSenses = [...filterSets['senses-filter']].some(selected => monsterSenses.includes(selected));
        }

        // Check toggle filters
        const matchesResistances = !requireResistances || hasResistances;
        const matchesLegendary = !requireLegendary || hasLegendary;

        // Show item only if it matches all filters
        if (matchesSearch && matchesLevel && matchesType && matchesSize &&
            matchesImmunities && matchesLanguages && matchesSenses &&
            matchesResistances && matchesLegendary) {
          item.style.display = '';
          visibleCount++;
        } else {
          item.style.display = 'none';
        }
      });

      // Update container visibility
      const container = document.getElementById('monsters-container');
      if (container) {
        container.style.display = visibleCount > 0 ? '' : 'none';
      }
    }

    // Update monster scaling based on level
    async function updateMonsterScaling(monsterId, baseCR) {
      const item = document.getElementById(`item-${monsterId}`);
      if (!item) return;

      const levelSelect = document.getElementById(`${monsterId}-level`);
      if (!levelSelect) return;

      const targetLevel = parseInt(levelSelect.value);
      const levelDiff = targetLevel - crToLevel(baseCR);
      const etfDiv = item.querySelector('.monster-etf-version');
      if (!etfDiv) return;

      // Get the original monster data
      const monsterIndex = parseInt(etfDiv.getAttribute('data-monster-index'));
      const data = await loadMonstersData();
      const sortedData = [...data].sort((a, b) =>
        a.cr !== b.cr ? a.cr - b.cr : a.name.localeCompare(b.name));
      const monster = sortedData[monsterIndex];

      // Clone, scale, and re-render
      const scaled = scaleMonsterData(monster, levelDiff);
      const ymiatBlock = renderStatBlock(scaled, true);
      etfDiv.innerHTML = ymiatBlock.innerHTML;

      // Update header level label
      const crLabel = document.getElementById(`${monsterId}-cr-label`);
      if (crLabel) crLabel.textContent = `Level ${targetLevel}`;
    }

    // Toggle filters visibility
    function toggleFilters() {
      const container = document.getElementById('filters-container');
      const btn = document.getElementById('toggle-filters-btn');
      const icons = btn.querySelectorAll('.toggle-filters-icon');

      if (container.style.display === 'none' || !container.style.display) {
        container.style.display = 'block';
        icons.forEach(i => i.textContent = '△');
      } else {
        container.style.display = 'none';
        icons.forEach(i => i.textContent = '▽');
      }
    }

    // Escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Multi-select filter state
    const filterSets = {
      'type-filter': new Set(),
      'size-filter': new Set(),
      'immunities-filter': new Set(),
      'languages-filter': new Set(),
      'senses-filter': new Set()
    };

    // Known immunity keywords for parsing
    const KNOWN_IMMUNITIES = [
      'acid', 'cold', 'fire', 'lightning', 'necrotic', 'poison',
      'psychic', 'radiant', 'thunder', 'bludgeoning', 'piercing', 'slashing',
      'blinded', 'charmed', 'deafened', 'exhaustion', 'frightened',
      'grappled', 'paralyzed', 'petrified', 'poisoned', 'prone',
      'restrained', 'unconscious'
    ];

    // Known languages for parsing
    const KNOWN_LANGUAGES = [
      'Common', 'Draconic', 'Elvish', 'Dwarvish', 'Giant', 'Goblin', 'Orc',
      'Abyssal', 'Celestial', 'Infernal', 'Primordial', 'Sylvan', 'Undercommon',
      'Deep Speech', 'Ignan', 'Terran', 'Aquan', 'Auran', 'Gnomish', 'Halfling',
      'Druidic', 'Telepathy'
    ];

    // Known senses for parsing
    const KNOWN_SENSES = ['darkvision', 'keensense', 'blindsight', 'tremorsense', 'truesight'];

    // Parse immunity string into individual keywords
    function parseImmunities(immunityStr) {
      if (!immunityStr) return [];
      const str = immunityStr.toLowerCase();
      const found = [];
      KNOWN_IMMUNITIES.forEach(keyword => {
        const regex = new RegExp('\\b' + keyword + '\\b');
        if (regex.test(str)) found.push(keyword);
      });
      return found;
    }

    // Parse language string into individual languages
    function parseLanguages(langStr) {
      if (!langStr || langStr === '–' || langStr === '-' || langStr === 'unknown') return [];
      const found = [];
      KNOWN_LANGUAGES.forEach(lang => {
        if (lang === 'Telepathy') {
          if (langStr.toLowerCase().includes('telepathy')) found.push(lang);
        } else {
          if (langStr.includes(lang)) found.push(lang);
        }
      });
      return found;
    }

    // Parse senses string into individual sense types
    function parseSenses(sensesStr) {
      if (!sensesStr || sensesStr === '–' || sensesStr === '-') return [];
      const str = sensesStr.toLowerCase();
      const found = [];
      KNOWN_SENSES.forEach(sense => {
        if (str.includes(sense)) found.push(sense);
      });
      return found;
    }

    // Multi-select dropdown functions
    function initializeMultiSelect(filterName, options) {
      const optionsContainer = document.getElementById(`${filterName}-options`);
      if (!optionsContainer) return;

      // Sort options alphabetically
      const sortedOptions = [...options].sort();

      // Create option elements
      sortedOptions.forEach(option => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'multi-select-option';
        optionDiv.textContent = option;
        optionDiv.onclick = (e) => {
          e.stopPropagation();
          toggleOption(filterName, option);
        };
        optionsContainer.appendChild(optionDiv);
      });
    }

    function toggleMultiSelect(filterName) {
      const optionsContainer = document.getElementById(`${filterName}-options`);
      if (!optionsContainer) return;

      // Close other dropdowns and reset their parent z-index
      document.querySelectorAll('.multi-select-options').forEach(el => {
        if (el.id !== `${filterName}-options`) {
          el.classList.remove('open');
          const parentFilter = el.closest('.multi-select-filter');
          if (parentFilter) parentFilter.style.zIndex = '';
        }
      });

      // Toggle current dropdown
      const isOpening = !optionsContainer.classList.contains('open');
      optionsContainer.classList.toggle('open');

      // Elevate the parent grid item so the menu appears above sibling filters
      const parentFilter = optionsContainer.closest('.multi-select-filter');
      if (parentFilter) {
        parentFilter.style.zIndex = isOpening ? '200' : '';
      }
    }

    function toggleOption(filterName, option) {
      const selectedSet = filterSets[filterName];
      if (!selectedSet) return;

      if (selectedSet.has(option)) {
        selectedSet.delete(option);
      } else {
        selectedSet.add(option);
      }

      updateChips(filterName, selectedSet);
      updateOptionStyles(filterName, selectedSet);
      applyFilters();
    }

    function removeChip(filterName, option) {
      const selectedSet = filterSets[filterName];
      if (!selectedSet) return;
      selectedSet.delete(option);
      updateChips(filterName, selectedSet);
      updateOptionStyles(filterName, selectedSet);
      applyFilters();
    }

    function updateChips(filterName, selectedSet) {
      const chipsContainer = document.getElementById(`${filterName}-chips`);
      const placeholder = document.getElementById(`${filterName}-placeholder`);
      const clearBtn = document.getElementById(`${filterName}-clear`);

      if (!chipsContainer || !placeholder) return;

      chipsContainer.innerHTML = '';

      if (selectedSet.size === 0) {
        placeholder.style.display = 'inline';
        if (clearBtn) clearBtn.style.display = 'none';
      } else {
        placeholder.style.display = 'none';
        if (clearBtn) clearBtn.style.display = 'block';
        selectedSet.forEach(option => {
          const chip = document.createElement('div');
          chip.className = 'multi-select-chip';
          const safeOption = option.replace(/'/g, "\\'");
          chip.innerHTML = `
        <span>${escapeHtml(option)}</span>
        <span class="multi-select-chip-remove" onclick="event.stopPropagation(); removeChip('${filterName}', '${safeOption}')">×</span>
      `;
          chipsContainer.appendChild(chip);
        });
      }
    }

    function clearAll(filterName) {
      const selectedSet = filterSets[filterName];
      if (!selectedSet) return;
      selectedSet.clear();
      updateChips(filterName, selectedSet);
      updateOptionStyles(filterName, selectedSet);
      applyFilters();
    }

    function updateOptionStyles(filterName, selectedSet) {
      const optionsContainer = document.getElementById(`${filterName}-options`);
      if (!optionsContainer) return;

      const options = optionsContainer.querySelectorAll('.multi-select-option');
      options.forEach(option => {
        if (selectedSet.has(option.textContent)) {
          option.classList.add('selected');
        } else {
          option.classList.remove('selected');
        }
      });
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', function (e) {
      if (!e.target.closest('.multi-select-dropdown')) {
        document.querySelectorAll('.multi-select-options').forEach(el => {
          el.classList.remove('open');
          const parentFilter = el.closest('.multi-select-filter');
          if (parentFilter) parentFilter.style.zIndex = '';
        });
      }
    });

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', async function () {
      // Load monsters data first to extract unique filter options
      const data = await loadMonstersData();

      // Extract unique types and sizes
      const types = new Set();
      const sizes = new Set();
      const immunitiesSet = new Set();
      const languagesSet = new Set();
      const sensesSet = new Set();

      data.forEach(monster => {
        if (monster.type) types.add(monster.type);
        if (monster.size) sizes.add(monster.size);

        // Extract immunities
        const ymiat = monster.ymiat || {};
        if (ymiat.immunities) {
          parseImmunities(ymiat.immunities).forEach(i => immunitiesSet.add(i));
        }

        // Extract languages
        if (ymiat.languages) {
          parseLanguages(ymiat.languages).forEach(l => languagesSet.add(l));
        }

        // Extract senses
        if (ymiat.senses) {
          parseSenses(ymiat.senses).forEach(s => sensesSet.add(s));
        }
      });

      // Initialize multi-select dropdowns
      initializeMultiSelect('type-filter', types);
      initializeMultiSelect('size-filter', sizes);
      initializeMultiSelect('immunities-filter', immunitiesSet);
      initializeMultiSelect('languages-filter', languagesSet);
      initializeMultiSelect('senses-filter', sensesSet);

      // Render monsters
      renderMonsters();

      // Initialize filters hidden
      const filtersContainer = document.getElementById('filters-container');
      if (filtersContainer) {
        filtersContainer.style.display = 'none';
      }

      // Initialize slider ticks for level filter (default)
      updateSliderTicks();
    });
  </script>
  <script src="../assets/site.js"></script>
</body>

</html>
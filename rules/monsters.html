<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Monsters | You-Meet-In-A-Tavern (YMIAT)</title>
<meta name="description" content="Monster stat blocks for You-Meet-In-A-Tavern (YMIAT)." />
<link rel="canonical" href="rules/monsters.html" />
<link rel="stylesheet" href="../assets/styles.css" />
<script src="../assets/includes.js"></script>
<meta property="og:title" content="Monsters | You-Meet-In-A-Tavern (YMIAT)" />
<meta property="og:description" content="Monster stat blocks for You-Meet-In-A-Tavern (YMIAT)." />
<meta property="og:type" content="website" />
<meta property="og:url" content="rules/monsters.html" />
<style>
/* CR Filter Dual Range Slider Styles */
.cr-filter-slider-container {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin: 15px 0;
  width: 100%;
}

.cr-slider-wrapper {
  position: relative;
  width: 100%;
  height: 50px;
  margin: 20px 0;
}

.cr-slider-track {
  position: absolute;
  width: 100%;
  height: 6px;
  background: #ddd;
  border-radius: 3px;
  top: 50%;
  transform: translateY(-50%);
}

.cr-slider-track::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-image: repeating-linear-gradient(
    to right,
    transparent 0,
    transparent calc(100% / 31 - 1px),
    #999 calc(100% / 31 - 1px),
    #999 calc(100% / 31)
  );
  pointer-events: none;
}

.cr-slider {
  position: absolute;
  width: 100%;
  height: 6px;
  background: transparent;
  outline: none;
  -webkit-appearance: none;
  pointer-events: none;
  top: 50%;
  transform: translateY(-50%);
}

.cr-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4a90e2;
  cursor: pointer;
  pointer-events: all;
  border: 2px solid #fff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  position: relative;
  z-index: 2;
}

.cr-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4a90e2;
  cursor: pointer;
  border: 2px solid #fff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  pointer-events: all;
}

.cr-slider-min {
  z-index: 1;
}

.cr-slider-max {
  z-index: 2;
}

.cr-slider-labels {
  display: flex;
  justify-content: space-between;
  margin-top: 5px;
  font-size: 0.9em;
  color: var(--text-secondary);
}

.cr-slider-label-min,
.cr-slider-label-max {
  font-weight: bold;
  color: #4a90e2;
}

.monster-item {
  margin-bottom: 20px;
}

.monster-stat-block-content {
  margin-top: 10px;
}

.monster-etf-version {
  display: block;
}

.monster-original-version {
  display: none;
}

.monster-controls-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 20px;
  margin: 15px 0;
  padding: 10px;
  background: #f5f5f5;
  border-radius: 5px;
}

.monster-level-scaling {
  display: flex;
  align-items: center;
  gap: 10px;
}

.monster-level-scaling label {
  font-weight: bold;
  margin: 0;
}

.monster-level-scaling select {
  padding: 5px 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 14px;
}

/* Individual monster toggle switch */
.monster-toggle-switch {
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  user-select: none;
}

.monster-toggle-switch input {
  display: none;
}

.monster-toggle-slider {
  position: relative;
  width: 44px;
  height: 24px;
  background: #ccc;
  border-radius: 24px;
  transition: background 0.3s;
}

.monster-toggle-slider::before {
  content: '';
  position: absolute;
  width: 18px;
  height: 18px;
  left: 3px;
  top: 3px;
  background: white;
  border-radius: 50%;
  transition: transform 0.3s;
}

.monster-toggle-switch input:checked + .monster-toggle-slider {
  background: var(--brand-secondary);
}

.monster-toggle-switch input:checked + .monster-toggle-slider::before {
  transform: translateX(20px);
}

.monster-toggle-label {
  font-size: 0.9rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.lineage-subtitle {
  font-size: 0.9em;
  color: var(--text-secondary);
  font-weight: normal;
  margin-left: 10px;
}

@media (prefers-color-scheme: dark) {
  .monster-controls-row {
    background: rgba(255, 255, 255, 0.05);
  }
}
</style>
</head>
<body>
<header data-include="nav"></header>
<main>
  <h1>Monsters</h1>
  <div class="content">
    <p class="lede">This page contains monster stat blocks from the Black Flag Reference Document, converted to the <strong>You-Meet-In-A-Tavern</strong> (YMIAT) system. All monsters are displayed with their <strong>You-Meet-In-A-Tavern</strong> (YMIAT)-converted stats by default, with the option to view original D&D 5e stat blocks.</p>
    
    <p>Monsters can be scaled to different levels using the level dropdown. This adjusts Defense Save DCs, damage, and other scalable properties based on the monster's Challenge Rating (CR).</p>

    <h2>Browse Monsters by Challenge Rating</h2>
    <p>View monsters organized by their Challenge Rating (CR). Hover over a CR button to see all monsters at that level:</p>
    <div class="btnrow" id="cr-buttons">
      <!-- CR buttons with dropdowns will be generated here by JavaScript -->
    </div>
    <script src="monsters-bfrd-index.js"></script>
    <script>
      // Function to create dropdown button HTML
      function createCRButton(cr, filename) {
        const monsters = monstersByCR[cr] || [];
        let html = '<div class="btn-dropdown">';
        html += `<a class="btn" href="monsters-bfrd/${filename}">CR ${cr}</a>`;

        if (monsters.length > 0) {
          html += '<div class="btn-dropdown-menu">';
          monsters.forEach(monster => {
            html += `<a href="monsters-bfrd/${filename}#${monster.slug}">${monster.name}</a>`;
          });
          html += '</div>';
        }

        html += '</div>';
        return html;
      }

      // Initialize CR buttons
      function initializeCRButtons() {
        const crPages = [
          { cr: '0', file: 'monster-cr-0.html' },
          { cr: '1/8', file: 'monster-cr-1-8.html' },
          { cr: '1/4', file: 'monster-cr-1-4.html' },
          { cr: '1/2', file: 'monster-cr-1-2.html' },
          { cr: '1', file: 'monster-cr-1.html' },
          { cr: '2', file: 'monster-cr-2.html' },
          { cr: '3', file: 'monster-cr-3.html' },
          { cr: '4', file: 'monster-cr-4.html' },
          { cr: '5', file: 'monster-cr-5.html' },
          { cr: '6', file: 'monster-cr-6.html' },
          { cr: '7', file: 'monster-cr-7.html' },
          { cr: '8', file: 'monster-cr-8.html' },
          { cr: '9', file: 'monster-cr-9.html' },
          { cr: '10', file: 'monster-cr-10.html' },
          { cr: '11', file: 'monster-cr-11.html' },
          { cr: '12', file: 'monster-cr-12.html' },
          { cr: '13', file: 'monster-cr-13.html' },
          { cr: '14', file: 'monster-cr-14.html' },
          { cr: '15', file: 'monster-cr-15.html' },
          { cr: '16', file: 'monster-cr-16.html' },
          { cr: '17', file: 'monster-cr-17.html' },
          { cr: '18', file: 'monster-cr-18.html' },
          { cr: '19', file: 'monster-cr-19.html' },
          { cr: '20', file: 'monster-cr-20.html' },
          { cr: '21', file: 'monster-cr-21.html' },
          { cr: '23', file: 'monster-cr-23.html' },
          { cr: '30', file: 'monster-cr-30.html' }
        ];

        // Generate buttons with dropdowns
        const buttonContainer = document.getElementById('cr-buttons');
        const buttonsHTML = crPages.map(page => createCRButton(page.cr, page.file)).join('');
        buttonContainer.innerHTML = buttonsHTML;
      }

      // Initialize when page loads
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeCRButtons);
      } else {
        initializeCRButtons();
      }
    </script>

    <div class="print-controls">
      <div class="search-row">
        <label for="monster-search" class="search-label">Search monsters:</label>
        <input type="text" id="monster-search" class="spell-search-input" placeholder="Type monster name to search..." oninput="handleMonsterSearch()" />
        <button id="toggle-filters-btn" class="toggle-filters-btn" onclick="toggleFilters()" title="Show/Hide filters">
          <span class="toggle-filters-icon">▼</span>
          <span class="toggle-filters-text">Filters</span>
        </button>
      </div>
      <div id="filters-container" class="filters-container">
        <div class="filter-row">
          <span class="filter-label" id="filter-label">Filter by Level:</span>
          <div class="cr-filter-slider-container">
            <div class="cr-slider-wrapper">
              <div class="cr-slider-track"></div>
              <input type="range" id="cr-min-slider" class="cr-slider cr-slider-min" min="1" max="10" value="1" step="1" oninput="updateCRFilter()" />
              <input type="range" id="cr-max-slider" class="cr-slider cr-slider-max" min="1" max="10" value="10" step="1" oninput="updateCRFilter()" />
            </div>
            <div class="cr-slider-labels">
              <span class="cr-slider-label-min">Min: <span id="cr-min-value">1</span></span>
              <span class="cr-slider-label-max">Max: <span id="cr-max-value">10</span></span>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="lineages-controls">
      <button id="expand-all-monsters" class="lineage-control-btn" onclick="expandAllMonsters()">Expand All</button>
      <button id="collapse-all-monsters" class="lineage-control-btn" onclick="collapseAllMonsters()">Collapse All</button>
    </div>
    
    <div class="lineages-container" id="monsters-container">
      <!-- Monsters will be loaded here via JavaScript -->
    </div>
  </div>
</main>
<footer class="legal" data-include="footer"></footer>
<script src="../data/monsters_data.js"></script>
<script>
// CR to Level mapping (same as monster-abilities.html)
function crToLevel(cr) {
  if (cr <= 0) return 1;
  if (cr <= 1) return 1;
  if (cr <= 3) return 2;
  if (cr <= 5) return 3;
  if (cr <= 7) return 4;
  if (cr <= 9) return 5;
  if (cr <= 11) return 6;
  if (cr <= 13) return 7;
  if (cr <= 15) return 8;
  if (cr <= 17) return 9;
  return 10;
}

// Calculate scaling adjustments
function calculateScaling(baseCR, targetLevel) {
  const baseLevel = crToLevel(baseCR);
  const levelDiff = targetLevel - baseLevel;
  
  return {
    dcAdjustment: levelDiff,
    damageAdjustment: Math.ceil(levelDiff / 2),
    hpAdjustment: levelDiff
  };
}

// Format CR value for display
function formatCR(cr) {
  if (cr === 0) return '0';
  if (cr === 0.125) return '1/8';
  if (cr === 0.25) return '1/4';
  if (cr === 0.5) return '1/2';
  return cr.toString();
}

// Parse CR value from string
function parseCR(crStr) {
  if (crStr === '0') return 0;
  if (crStr === '1/8') return 0.125;
  if (crStr === '1/4') return 0.25;
  if (crStr === '1/2') return 0.5;
  return parseFloat(crStr) || 0;
}

// Load monsters data
let monstersData = [];
let originalETFContent = new Map();
let original5eContent = new Map();

async function loadMonstersData() {
  if (monstersData.length > 0) return monstersData;
  
  // Data is embedded in the page via script tag, so it should already be available
  // Check if monstersDataEmbedded is defined (from embedded script)
  if (typeof monstersDataEmbedded !== 'undefined') {
    monstersData = monstersDataEmbedded;
    return monstersData;
  }
  
  // Also check window object
  if (typeof window.monstersDataEmbedded !== 'undefined') {
    monstersData = window.monstersDataEmbedded;
    return monstersData;
  }
  
  // Fallback: return empty array if data not found
  console.warn('Monsters data not found. Make sure monsters_data.js is included.');
  return [];
}

// Render monsters with optimized batch rendering
async function renderMonsters() {
  const data = await loadMonstersData();
  const container = document.getElementById('monsters-container');
  
  if (!container) return;
  
  // Show loading indicator
  container.innerHTML = '<p>Loading monsters...</p>';
  
  // Sort monsters by CR, then by name
  const sorted = [...data].sort((a, b) => {
    if (a.cr !== b.cr) return a.cr - b.cr;
    return a.name.localeCompare(b.name);
  });
  
  // Build HTML string in memory first (much faster than innerHTML +=)
  const htmlParts = [];
  
  sorted.forEach((monster, index) => {
    const monsterId = `monster-${index}`;
    const safeId = monsterId.replace(/[^a-z0-9-]/gi, '-');
    const defaultLevel = crToLevel(monster.cr);
    
    const monsterLevel = monster.level || crToLevel(monster.cr);
    htmlParts.push(`
      <div class="lineage-item monster-item" data-monster-name="${escapeHtml(monster.name.toLowerCase())}" data-cr="${monster.cr}" data-level="${monsterLevel}" id="item-${safeId}">
        <button class="lineage-header" onclick="toggleMonster(this)">
          <span class="lineage-title">${escapeHtml(monster.name)}</span>
          <span class="lineage-subtitle" id="${safeId}-cr-label">Level ${monsterLevel}</span>
          <span class="lineage-toggle-icon">▼</span>
        </button>
        <div class="lineage-content">
          <div class="monster-controls-row">
            <div class="monster-level-scaling">
              <label for="${safeId}-level">Scale for level:</label>
              <select id="${safeId}-level" class="level-scaling-select" onchange="updateMonsterScaling('${safeId}', ${monster.cr})">
                ${[1,2,3,4,5,6,7,8,9,10].map(lvl =>
                  `<option value="${lvl}" ${lvl === defaultLevel ? 'selected' : ''}>Level ${lvl}</option>`
                ).join('')}
              </select>
            </div>
            <label class="monster-toggle-switch">
              <input type="checkbox" id="${safeId}-toggle" onchange="toggleMonsterStats('${safeId}')">
              <span class="monster-toggle-slider"></span>
              <span class="monster-toggle-label">5e stats</span>
            </label>
          </div>
          <div class="monster-stat-block-content">
            <div class="monster-etf-version" id="${safeId}-etf">
              ${monster.etf_html}
            </div>
            <div class="monster-original-version" id="${safeId}-original" style="display:none;">
              ${monster.original_html}
            </div>
          </div>
          <div class="scaling-info" data-base-cr="${monster.cr}" data-base-hp="${monster.hp}" data-base-ac="${monster.ac}" style="display:none;"></div>
        </div>
      </div>
    `);
  });
  
  // Set innerHTML once with all content (much faster)
  container.innerHTML = htmlParts.join('');
  
  // Store original content after rendering (use requestAnimationFrame for better performance)
  requestAnimationFrame(() => {
    document.querySelectorAll('.monster-item').forEach(item => {
      const etfDiv = item.querySelector('.monster-etf-version');
      const originalDiv = item.querySelector('.monster-original-version');
      if (etfDiv && !originalETFContent.has(item)) {
        originalETFContent.set(item, etfDiv.innerHTML);
      }
      if (originalDiv && !original5eContent.has(item)) {
        original5eContent.set(item, originalDiv.innerHTML);
      }
    });
    
    // Initialize all collapsed
    document.querySelectorAll('.lineage-content').forEach(content => {
      content.style.display = 'none';
    });
    
    // Apply filters after rendering
    applyFilters();
  });
}

// Toggle monster accordion
function toggleMonster(button) {
  const item = button.closest('.lineage-item');
  const content = item.querySelector('.lineage-content');
  const icon = button.querySelector('.lineage-toggle-icon');
  const isExpanded = content.style.display === 'block' || content.classList.contains('expanded');

  if (isExpanded) {
    content.style.display = 'none';
    content.classList.remove('expanded');
    icon.textContent = '▼';
    button.setAttribute('aria-expanded', 'false');
  } else {
    content.style.display = 'block';
    content.classList.add('expanded');
    icon.textContent = '▲';
    button.setAttribute('aria-expanded', 'true');
  }
}

// Toggle between YMIAT and 5e stats for individual monster
function toggleMonsterStats(monsterId) {
  const toggle = document.getElementById(`${monsterId}-toggle`);
  const etfVersion = document.getElementById(`${monsterId}-etf`);
  const originalVersion = document.getElementById(`${monsterId}-original`);
  const crLabel = document.getElementById(`${monsterId}-cr-label`);

  // Get the monster item to access its data
  const item = document.getElementById(`item-${monsterId}`);
  if (!item) return;

  const cr = parseFloat(item.getAttribute('data-cr')) || 0;
  const level = parseInt(item.getAttribute('data-level')) || crToLevel(cr);

  if (toggle.checked) {
    // Show original 5e stats
    etfVersion.style.display = 'none';
    originalVersion.style.display = 'block';
    if (crLabel) crLabel.textContent = `CR ${formatCR(cr)}`;
  } else {
    // Show YMIAT stats
    etfVersion.style.display = 'block';
    originalVersion.style.display = 'none';
    if (crLabel) crLabel.textContent = `Level ${level}`;
  }
}

// Expand/Collapse all
function expandAllMonsters() {
  document.querySelectorAll('.lineage-content').forEach(content => {
    content.style.display = 'block';
    content.classList.add('expanded');
  });
  document.querySelectorAll('.lineage-toggle-icon').forEach(icon => {
    icon.textContent = '▲';
  });
  document.querySelectorAll('.lineage-header').forEach(button => {
    button.setAttribute('aria-expanded', 'true');
  });
}

function collapseAllMonsters() {
  document.querySelectorAll('.lineage-content').forEach(content => {
    content.style.display = 'none';
    content.classList.remove('expanded');
  });
  document.querySelectorAll('.lineage-toggle-icon').forEach(icon => {
    icon.textContent = '▼';
  });
  document.querySelectorAll('.lineage-header').forEach(button => {
    button.setAttribute('aria-expanded', 'false');
  });
}

// Toggle between You-Meet-In-A-Tavern (YMIAT) and Original stats
function toggleOriginalStats() {
  const showOriginal = document.getElementById('toggle-original-stats').checked;
  
  // Update filter slider based on toggle state
  const minSlider = document.getElementById('cr-min-slider');
  const maxSlider = document.getElementById('cr-max-slider');
  const minValue = document.getElementById('cr-min-value');
  const maxValue = document.getElementById('cr-max-value');
  const filterLabel = document.getElementById('filter-label');
  
  if (showOriginal) {
    // Show CR filter (0-30)
    filterLabel.textContent = 'Filter by CR (Challenge Rating):';
    minSlider.min = 0;
    minSlider.max = 30;
    minSlider.value = 0;
    maxSlider.min = 0;
    maxSlider.max = 30;
    maxSlider.value = 30;
    minValue.textContent = '0';
    maxValue.textContent = '30';
  } else {
    // Show Level filter (1-10)
    filterLabel.textContent = 'Filter by Level:';
    minSlider.min = 1;
    minSlider.max = 10;
    minSlider.value = 1;
    maxSlider.min = 1;
    maxSlider.max = 10;
    maxSlider.value = 10;
    minValue.textContent = '1';
    maxValue.textContent = '10';
  }
  
  // Update slider track tick marks
  updateSliderTicks();
  
  document.querySelectorAll('.monster-item').forEach(item => {
    const etfDiv = item.querySelector('.monster-etf-version');
    const originalDiv = item.querySelector('.monster-original-version');
    
    if (showOriginal) {
      if (etfDiv) etfDiv.style.display = 'none';
      if (originalDiv) originalDiv.style.display = 'block';
    } else {
      if (etfDiv) etfDiv.style.display = 'block';
      if (originalDiv) originalDiv.style.display = 'none';
    }
  });
  
  // Reapply filters with new criteria
  applyFilters();
}

// Update slider track tick marks based on current range
function updateSliderTicks() {
  const minSlider = document.getElementById('cr-min-slider');
  const maxSlider = document.getElementById('cr-max-slider');
  const track = document.querySelector('.cr-slider-track');
  
  if (!minSlider || !maxSlider || !track) return;
  
  const min = parseInt(minSlider.min);
  const max = parseInt(maxSlider.max);
  const range = max - min + 1;
  
  // Update CSS for tick marks
  track.style.backgroundImage = `repeating-linear-gradient(
    to right,
    transparent 0,
    transparent calc(100% / ${range} - 1px),
    #999 calc(100% / ${range} - 1px),
    #999 calc(100% / ${range})
  )`;
}

// Update CR/Level filter slider values
function updateCRFilter() {
  const minSlider = document.getElementById('cr-min-slider');
  const maxSlider = document.getElementById('cr-max-slider');
  const minValue = document.getElementById('cr-min-value');
  const maxValue = document.getElementById('cr-max-value');
  
  let min = parseInt(minSlider.value);
  let max = parseInt(maxSlider.value);
  
  // Ensure min <= max (they can be equal)
  if (min > max) {
    // If min slider moved past max, set min to max
    if (minSlider === document.activeElement) {
      min = max;
      minSlider.value = min;
    }
    // If max slider moved below min, set max to min
    else if (maxSlider === document.activeElement) {
      max = min;
      maxSlider.value = max;
    }
  }
  
  minValue.textContent = min;
  maxValue.textContent = max;
  
  // Apply filter
  applyFilters();
}

// Search functionality
function handleMonsterSearch() {
  applyFilters();
}

// Apply all filters
function applyFilters() {
  const searchTerm = (document.getElementById('monster-search')?.value || '').toLowerCase();
  const minSlider = document.getElementById('cr-min-slider');
  const maxSlider = document.getElementById('cr-max-slider');
  const showOriginal = false; // No global toggle - each monster has individual toggle
  
  if (!minSlider || !maxSlider) return;
  
  const minValue = parseInt(minSlider.value);
  const maxValue = parseInt(maxSlider.value);
  
  let visibleCount = 0;
  
  document.querySelectorAll('.monster-item').forEach(item => {
    const name = (item.getAttribute('data-monster-name') || '').toLowerCase();
    const matchesSearch = !searchTerm || name.includes(searchTerm);
    
    let matchesFilter = false;
    
    if (showOriginal) {
      // Filter by CR (for original D&D stats)
      const cr = parseFloat(item.getAttribute('data-cr')) || 0;
      const crInt = Math.round(cr);
      matchesFilter = crInt >= minValue && crInt <= maxValue;
    } else {
      // Filter by Level (for You-Meet-In-A-Tavern (YMIAT) stats)
      const level = parseInt(item.getAttribute('data-level')) || 1;
      matchesFilter = level >= minValue && level <= maxValue;
    }
    
    if (matchesSearch && matchesFilter) {
      item.style.display = '';
      visibleCount++;
    } else {
      item.style.display = 'none';
    }
  });
  
  // Update container visibility
  const container = document.getElementById('monsters-container');
  if (container) {
    container.style.display = visibleCount > 0 ? '' : 'none';
  }
}

// Update monster scaling based on level
function updateMonsterScaling(monsterId, baseCR) {
  const item = document.getElementById(`item-${monsterId}`);
  if (!item) return;
  
  const levelSelect = document.getElementById(`${monsterId}-level`);
  if (!levelSelect) return;
  
  const targetLevel = parseInt(levelSelect.value);
  const scaling = calculateScaling(baseCR, targetLevel);
  const etfDiv = item.querySelector('.monster-etf-version');
  
  if (!etfDiv) return;
  
  // Get original You-Meet-In-A-Tavern (YMIAT) content
  let etfHTML = originalETFContent.get(item);
  if (!etfHTML) {
    etfHTML = etfDiv.innerHTML;
    originalETFContent.set(item, etfHTML);
  }
  
  // Apply scaling
  let updatedHTML = etfHTML;
  
  // Scale Defense Save DCs (Defense Save DC XX)
  updatedHTML = updatedHTML.replace(/Defense Save DC (\d+)/g, (match, dc) => {
    const baseDC = parseInt(dc);
    const newDC = Math.max(1, baseDC + scaling.dcAdjustment);
    return `Defense Save DC ${newDC}`;
  });
  
  // Scale other DCs (escape DC, save DCs, etc.) - but avoid double-scaling Defense Save DCs
  // First, temporarily replace "Defense Save DC" to avoid matching it
  updatedHTML = updatedHTML.replace(/Defense Save DC/g, '___DEFENSE_SAVE_DC___');
  
  // Now scale all remaining DCs
  updatedHTML = updatedHTML.replace(/\bDC (\d+)/g, (match, dc) => {
    const baseDC = parseInt(dc);
    const newDC = Math.max(1, baseDC + scaling.dcAdjustment);
    return `DC ${newDC}`;
  });
  
  // Also handle "escape DC" and similar patterns
  updatedHTML = updatedHTML.replace(/(escape|save) DC (\d+)/gi, (match, type, dc) => {
    const baseDC = parseInt(dc);
    const newDC = Math.max(1, baseDC + scaling.dcAdjustment);
    return `${type} DC ${newDC}`;
  });
  
  // Restore "Defense Save DC"
  updatedHTML = updatedHTML.replace(/___DEFENSE_SAVE_DC___/g, 'Defense Save DC');
  
  // Scale HP
  const scalingInfo = item.querySelector('.scaling-info');
  if (scalingInfo) {
    const baseHP = parseInt(scalingInfo.getAttribute('data-base-hp')) || 1;
    const newHP = Math.max(1, baseHP + scaling.hpAdjustment);
    // Replace HP in the stat block
    updatedHTML = updatedHTML.replace(
      /<strong>Hit Points<\/strong>\s*(\d+)/gi,
      `<strong>Hit Points</strong> ${newHP}`
    );
  }
  
  // Update display
  etfDiv.innerHTML = updatedHTML;
}

// Toggle filters visibility
function toggleFilters() {
  const container = document.getElementById('filters-container');
  const btn = document.getElementById('toggle-filters-btn');
  const icon = btn.querySelector('.toggle-filters-icon');
  
  if (container.style.display === 'none' || !container.style.display) {
    container.style.display = 'block';
    icon.textContent = '▲';
  } else {
    container.style.display = 'none';
    icon.textContent = '▼';
  }
}

// Escape HTML
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
  // monsters_data.js should be loaded by now (it's before this script)
  renderMonsters();
  
  // Initialize filters hidden
  const filtersContainer = document.getElementById('filters-container');
  if (filtersContainer) {
    filtersContainer.style.display = 'none';
  }
  
  // Initialize slider ticks for level filter (default)
  updateSliderTicks();
});
</script>
<script src="../assets/site.js"></script>
</body>
</html>
